ğŸ”¹ 5. Design Patterns (TasarÄ±m KalÄ±plarÄ±)

â“ TasarÄ±m KalÄ±plarÄ± Nedir?
Design Pattern, tekrar eden yazÄ±lÄ±m problemlerine yÃ¶nelik evrensel ve test edilmiÅŸ Ã§Ã¶zÃ¼mlerdir. KarmaÅŸÄ±k yapÄ±larÄ± basitleÅŸtirmek, sÃ¼rdÃ¼rÃ¼lebilirliÄŸi artÄ±rmak iÃ§in kullanÄ±lÄ±r.
	ğŸ¯ KÄ±saca: "Bu sorunu daha Ã¶nce yaÅŸayanlar bunu ÅŸÃ¶yle Ã§Ã¶zmÃ¼ÅŸ."

ğŸ§© ABAPâ€™ta En Ã‡ok KullanÄ±lan TasarÄ±m KalÄ±plarÄ±

ğŸ”¸ 1. Singleton Pattern
ğŸ“Œ AmaÃ§:
Bir sÄ±nÄ±fÄ±n yalnÄ±zca tek bir Ã¶rneÄŸi (instance) oluÅŸturulsun. Tek merkezden yÃ¶netilsin.
ğŸ§± KullanÄ±m:

CLASS lcl_logger DEFINITION CREATE PRIVATE.
  PUBLIC SECTION.
    CLASS-METHODS: get_instance RETURNING VALUE(ro_inst) TYPE REF TO lcl_logger.
    METHODS: log_message IMPORTING iv_msg TYPE string.
  PRIVATE SECTION.
    CLASS-DATA: mo_instance TYPE REF TO lcl_logger.
ENDCLASS.

CLASS lcl_logger IMPLEMENTATION.

  METHOD get_instance.
    IF mo_instance IS INITIAL.
      CREATE OBJECT mo_instance.
    ENDIF.
    ro_inst = mo_instance.
  ENDMETHOD.

  METHOD log_message.
    WRITE: / 'Log:', iv_msg.
  ENDMETHOD.

ENDCLASS.

START-OF-SELECTION.
  DATA(logger) = lcl_logger=>get_instance( ).
  logger->log_message( 'Ä°ÅŸlem baÅŸladÄ±.' ).

  " Her Ã§aÄŸrÄ±da aynÄ± nesne dÃ¶ner
  DATA(again) = lcl_logger=>get_instance( ).
  IF logger = again.
    WRITE: / 'AynÄ± nesne, Singleton Ã§alÄ±ÅŸÄ±yor!'.
  ENDIF.




ğŸ”¸ 2. Factory Pattern
ğŸ“Œ AmaÃ§:
Nesne oluÅŸturma iÅŸlemi sÄ±nÄ±f iÃ§inde merkezileÅŸtirilsin ve koÅŸullara gÃ¶re farklÄ± tÃ¼rde nesneler dÃ¶ndÃ¼rÃ¼lsÃ¼n.
ğŸ§± Ã–rnek:



INTERFACE if_hayvan.
  METHODS: ses_cikar.
ENDINTERFACE.

CLASS lcl_kedi DEFINITION.
  PUBLIC SECTION.
    INTERFACES if_hayvan.
ENDCLASS.

CLASS lcl_kedi IMPLEMENTATION.
  METHOD if_hayvan~ses_cikar.
    WRITE: / 'Miyav!'.
  ENDMETHOD.
ENDCLASS.

CLASS lcl_kopek DEFINITION.
  PUBLIC SECTION.
    INTERFACES if_hayvan.
ENDCLASS.

CLASS lcl_kopek IMPLEMENTATION.
  METHOD if_hayvan~ses_cikar.
    WRITE: / 'Hav hav!'.
  ENDMETHOD.
ENDCLASS.

" Factory sÄ±nÄ±fÄ±
CLASS lcl_hayvan_factory DEFINITION.
  PUBLIC SECTION.
    CLASS-METHODS: create_hayvan 
      IMPORTING iv_tur TYPE string
      RETURNING VALUE(ro_hayvan) TYPE REF TO if_hayvan.
ENDCLASS.

CLASS lcl_hayvan_factory IMPLEMENTATION.
  METHOD create_hayvan.
    CASE iv_tur.
      WHEN 'kedi'.
        CREATE OBJECT ro_hayvan TYPE lcl_kedi.
      WHEN 'kopek'.
        CREATE OBJECT ro_hayvan TYPE lcl_kopek.
      WHEN OTHERS.
        ro_hayvan = NULL.
    ENDCASE.
  ENDMETHOD.
ENDCLASS.

START-OF-SELECTION.
  DATA hayvan TYPE REF TO if_hayvan.
  hayvan = lcl_hayvan_factory=>create_hayvan( 'kopek' ).
  IF hayvan IS BOUND.
    hayvan->ses_cikar( ).
  ENDIF.



ğŸ”¸ 3. Strategy Pattern
ğŸ“Œ AmaÃ§:
Bir iÅŸlemi farklÄ± stratejilere gÃ¶re deÄŸiÅŸtirebilir hale getirmek (Ã¶rnek: sÄ±ralama, hesaplama, fiyatlandÄ±rma).
ğŸ§± KullanÄ±m:
Fiyat hesaplamasÄ± farklÄ± kurallara gÃ¶re olsun ama kod deÄŸiÅŸmesin, sadece strateji deÄŸiÅŸsin.

ğŸ”¸ 4. Observer Pattern
Bu aslÄ±nda Event / Handler mekanizmasÄ±dÄ±r. YayÄ±ncÄ± bir sÄ±nÄ±f var, birden Ã§ok abone dinliyor. YukarÄ±da detaylÄ± iÅŸledik ğŸ¯

ğŸ¯ TasarÄ±m KalÄ±plarÄ±nÄ±n FaydalarÄ±
	â€¢ Kod tekrarÄ±nÄ± azaltÄ±r
	â€¢ GeniÅŸletilebilirliÄŸi artÄ±rÄ±r (Open/Closed Principle)
	â€¢ Test etmeyi kolaylaÅŸtÄ±rÄ±r
	â€¢ SÄ±nÄ±flar arasÄ± baÄŸÄ±mlÄ±lÄ±ÄŸÄ± dÃ¼ÅŸÃ¼rÃ¼r
	â€¢ TakÄ±m Ã§alÄ±ÅŸmasÄ±nda anlaÅŸÄ±labilir yapÄ±lar saÄŸlar

